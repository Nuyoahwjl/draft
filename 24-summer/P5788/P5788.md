# 【模板】单调栈

## 题目背景

模板题，无背景。  

2019.12.12 更新数据，放宽时限，现在不再卡常了。

## 题目描述

给出项数为 $n$ 的整数数列 $a_{1 \dots n}$。

定义函数 $f(i)$ 代表数列中第 $i$ 个元素之后第一个大于 $a_i$ 的元素的**下标**，即 $f(i)=\min_{i<j\leq n, a_j > a_i} \{j\}$。若不存在，则 $f(i)=0$。

试求出 $f(1\dots n)$。

## 输入格式

第一行一个正整数 $n$。

第二行 $n$ 个正整数 $a_{1\dots n}$。

## 输出格式

一行 $n$ 个整数表示 $f(1), f(2), \dots, f(n)$ 的值。

## 样例 #1

### 样例输入 #1

```
5
1 4 2 3 5
```

### 样例输出 #1

```
2 5 4 5 0
```

## 提示

【数据规模与约定】

对于 $30\%$ 的数据，$n\leq 100$；

对于 $60\%$ 的数据，$n\leq 5 \times 10^3$ ；

对于 $100\%$ 的数据，$1 \le n\leq 3\times 10^6$，$1\leq a_i\leq 10^9$。
<br>
<br>
<br>
<br>
<br>
<br>





# 下面是一个基于单调栈的C语言代码实现，用于求解给定数列中每个元素之后第一个大于它的元素的下标。

### 详细步骤
1. 初始化一个栈用于存储数组的下标。
2. 遍历数组，对于每一个元素 `a[i]`：
   - 如果栈不为空且当前元素 `a[i]` 大于栈顶元素对应的数组值 `a[stack[top]]`，则说明找到了栈顶元素之后第一个比它大的元素，因此可以将 `f(stack[top])` 赋值为当前下标 `i`，并将栈顶元素弹出。
   - 将当前元素的下标 `i` 压入栈中。
3. 最后，栈中剩余的元素都没有找到比它们大的后续元素，因此它们对应的 `f(i)` 应为 `0`。

### C语言实现

```c
#include <stdio.h>
#include <stdlib.h>

#define MAX_N 3000000  // 最大 n 的值

int a[MAX_N + 1];
int f[MAX_N + 1];
int stack[MAX_N + 1];
int top = -1;

int main() {
    int n;
    scanf("%d", &n);

    for (int i = 1; i <= n; i++) {
        scanf("%d", &a[i]);
    }

    // 单调栈的实现
    for (int i = 1; i <= n; i++) {
        while (top >= 0 && a[stack[top]] < a[i]) {
            f[stack[top]] = i;
            top--;
        }
        stack[++top] = i;
    }

    // 栈中剩下的元素没有更大的元素，所以赋值为 0
    while (top >= 0) {
        f[stack[top]] = 0;
        top--;
    }

    // 输出结果
    for (int i = 1; i <= n; i++) {
        printf("%d ", f[i]);
    }
    printf("\n");

    return 0;
}
```

### 代码说明
- **数组`a`** 用于存储输入的整数数列。
- **数组`f`** 用于存储每个元素后第一个大于它的元素的下标。
- **数组`stack`** 用于实现单调栈，存储数组下标。
- **变量`top`** 作为栈顶指针，初始化为 `-1` 表示栈为空。

### 时间复杂度
- 该算法的时间复杂度为 `O(n)`，因为每个元素最多进栈和出栈各一次，适合处理大规模数据。

### 运行方式
将代码复制到一个C语言编译器中编译并运行，输入样例数据即可得到正确输出。

**a.** 添加更多的边界测试用例验证该程序的正确性。

**b.** 进一步优化代码，提升其性能或可读性。
